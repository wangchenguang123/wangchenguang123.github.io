[{"content":"提交Hugo 启动博客 1 hugo server --theme=hugo-theme-stack -D 2.提交md文件\n1 2 hugo new post/XXXX.md 在生成md文件后将draft的属性值改为false 3.绑定github仓库\n1 hugo --theme=hugo-theme-stack --baseUrl=\u0026#34;https://wangchenguang123.github.io/\u0026#34; -D 4.进入public文件夹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 如果是第一次提交 cd public git init git add . git commit -m \u0026#34;message\u0026#34; git remote add origin https://github.com/wangchenguang123/wangchenguang123.github.io.git git push -u origin master 如果不是第一次提交 hugo new post/xxx.md hugo --theme=m10c --baseUrl=\u0026#34;https://wangchenguang123.github.io/\u0026#34; -D cd public git add . git commit -m \u0026#34;message\u0026#34; git push 5.图片问题\n1 2 3 4 图片放在 static 目录下 ![](/images/images.jpg) 图片放在博客文件名相同的文件夹中 ![](images.jpg) ","date":"2023-05-19T22:15:17+08:00","image":"https://wangchenguang123.github.io/the-creative-exchange-d2zvqp3fpro-unsplash.jpg","permalink":"https://wangchenguang123.github.io/p/hugo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4/","title":"Hugo博客提交"},{"content":"开源Springboot项目-sql之父 项目引用依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本(HTML 网页，电子邮件，配置文件，源代码等)的通用工具。它不是面向最终用户的，而是一个 Java 类库，是一款程序员可以嵌入他们所开发产品的组件。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 生成接口文档使用的依赖库 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 阿里巴巴出的数据库连接池 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;easyexcel\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 阿里巴巴出的好用的excel库 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; java工具的增强版 2.项目主要结构 学习的地方： 1.注解的使用：自定义一个权限检测注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Target(ElementType.METHOD) 函数级别的 @Retention(RetentionPolicy.RUNTIME) 运行时 public @interface AuthCheck { /** * 有任何一个角色 * * @return */ String[] anyRole() default \u0026#34;\u0026#34;; /** * 必须有某个角色 * * @return */ String mustRole() default \u0026#34;\u0026#34;; } 2.使用Aop进行权限控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Around(\u0026#34;@annotation(authCheck)\u0026#34;) public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable { List\u0026lt;String\u0026gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList()); String mustRole = authCheck.mustRole(); RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes(); HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest(); // 当前登录用户 User user = userService.getLoginUser(request); // 拥有任意权限即通过 /* 下列为代码逻辑可以更改 */ if (CollectionUtils.isNotEmpty(anyRole)) { String userRole = user.getUserRole(); if (!anyRole.contains(userRole)) { throw new BusinessException(ErrorCode.NO_AUTH_ERROR); } } // 必须有所有权限才通过 if (StringUtils.isNotBlank(mustRole)) { String userRole = user.getUserRole(); if (!mustRole.equals(userRole)) { throw new BusinessException(ErrorCode.NO_AUTH_ERROR); } } // 通过权限校验，放行 return joinPoint.proceed(); } 1 @Around(\u0026#34;execution(* com.yupi.sqlfather.controller.*.*(..))\u0026#34;) 3.全局配置 主要配置FreeMarker,Knife4j和MybatisPlus具体配置内容可根据需要进行百度 下面展示跨域配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 覆盖所有请求 registry.addMapping(\u0026#34;/**\u0026#34;) // 允许发送 Cookie .allowCredentials(true) // 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突） .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .exposedHeaders(\u0026#34;*\u0026#34;); } } 针对每一个配置都需要写@Configuration才能注入到SpringBoot项目当中 4.通用返回类配置 实现一个通用返回类，符合RestfulApi风格的接口 定义code,data和返回信息，对于data需要进行泛型处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @Data lomok风格自动生成Get和Set public class BaseResponse\u0026lt;T\u0026gt; implements Serializable { private int code; private T data; private String message; public BaseResponse(int code, T data, String message) { this.code = code; this.data = data; this.message = message; } public BaseResponse(int code, T data) { this(code, data, \u0026#34;\u0026#34;); } public BaseResponse(ErrorCode errorCode) { this(errorCode.getCode(), null, errorCode.getMessage()); } } 上述代码中使用的Errorcode则是一个枚举类，枚举可能发生的错误代码和提示信息 public enum ErrorCode { SUCCESS(0, \u0026#34;ok\u0026#34;), PARAMS_ERROR(40000, \u0026#34;请求参数错误\u0026#34;), NOT_LOGIN_ERROR(40100, \u0026#34;未登录\u0026#34;), NO_AUTH_ERROR(40101, \u0026#34;无权限\u0026#34;), NOT_FOUND_ERROR(40400, \u0026#34;请求数据不存在\u0026#34;), FORBIDDEN_ERROR(40300, \u0026#34;禁止访问\u0026#34;), SYSTEM_ERROR(50000, \u0026#34;系统内部异常\u0026#34;), OPERATION_ERROR(50001, \u0026#34;操作失败\u0026#34;); /** * 状态码 */ private final int code; /** * 信息 */ private final String message; ErrorCode(int code, String message) { this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; } } 分页也需要一个单独的类来进行控制，其中主要包含属性为页号，页面大小，总数等等 定义一个返回的工具类，工具类中主要实现以BaseRespose为对象的方法， public class ResultUtils { /** * 成功 * * @param data * @param \u0026lt;T\u0026gt; * @return */ public static \u0026lt;T\u0026gt; BaseResponse\u0026lt;T\u0026gt; success(T data) { return new BaseResponse\u0026lt;\u0026gt;(0, data, \u0026#34;ok\u0026#34;); } /** * 失败 * * @param errorCode * @return */ public static BaseResponse error(ErrorCode errorCode) { return new BaseResponse\u0026lt;\u0026gt;(errorCode); } /** * 失败 * * @param code * @param message * @return */ public static BaseResponse error(int code, String message) { return new BaseResponse(code, null, message); } /** * 失败 * * @param errorCode * @return */ public static BaseResponse error(ErrorCode errorCode, String message) { return new BaseResponse(errorCode.getCode(), null, message); } 5.全局异常配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 自定义异常类，自定义的异常类主要继承RuntimeException public class BusinessException extends RuntimeException { private final int code; public BusinessException(int code, String message) { super(message); this.code = code; } public BusinessException(ErrorCode errorCode) { super(errorCode.getMessage()); this.code = errorCode.getCode(); } public BusinessException(ErrorCode errorCode, String message) { super(message); this.code = errorCode.getCode(); } public int getCode() { return code; } } 定义全局异常处理方法 @RestControllerAdvice 在捕获各种异常是使用 @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(BusinessException.class) 在出现异常时使用用户自定义异常类进行处理 public BaseResponse\u0026lt;?\u0026gt; businessExceptionHandler(BusinessException e) { log.error(\u0026#34;businessException: \u0026#34; + e.getMessage(), e); return ResultUtils.error(e.getCode(), e.getMessage()); } @ExceptionHandler(RuntimeException.class) 运行时异常，中断，并报错。 public BaseResponse\u0026lt;?\u0026gt; runtimeExceptionHandler(RuntimeException e) { log.error(\u0026#34;runtimeException\u0026#34;, e);```` return ResultUtils.error(ErrorCode.SYSTEM_ERROR, e.getMessage()); } } 6.业务逻辑学习\nStringUtils.isAnyBlank 只要有一个为空则显示为True,所以可以放到检测用户登录时进行校验 synchronized (userAccount.intern()) {}是为了确保在synchronized代码块中对相同userAccount值的锁定是有效的。通过将userAccount字符串调用intern()方法，确保获取的字符串是字符串池中的引用，从而使得不同线程可以正确地对相同userAccount值进行锁定和同步操作。 String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());MD5加密算法，加密用户名密码。 // 3. 记录用户的登录态 request.getSession().setAttribute(USER_LOGIN_STATE, user); 记住用户的登陆状态 获取枚举类中的值列表 1 2 3 public static List\u0026lt;String\u0026gt; getValues() { return Arrays.stream(values()).map(FieldTypeEnum::getValue).collect(Collectors.toList()); } BeanUtils.copyProperties(user, userVO) 源对象和目标对象。它将源对象中的属性值复制到目标对象中对应的属性上，通过属性名称进行匹配。属性名称和类型必须在源对象和目标对象中相匹配，否则会抛出异常。 StringUtils.isNotBlank(***) 不为空 对于字符串的判断可以多用已完成的工具，避免重复造轮子还不准，上述主要使用StringUtils Optional.ofNullable 判断对象是否为空 针对工厂模式的运用也是主要的特色之一，针对随机，递增，默认等方式都实现了一个数据生成器接口，而工厂模式，获取实现了这个数据生成器接口的实例。 public static SQLDialect getDialect(String className) { SQLDialect dialect = DIALECT_POOL.get(className); if (null == dialect) { synchronized (className.intern()) { dialect = DIALECT_POOL.computeIfAbsent(className, key -\u0026gt; { try { return (SQLDialect) Class.forName(className).newInstance(); } catch (Exception e) { throw new BusinessException(ErrorCode.SYSTEM_ERROR); } }); } } return dialect; } 上述是一个单例模式的实现，运用在实际项目中 1 2 3 * 主要需要理解到DTO的设计，不要一直使用最初的实体类，因为可能会有很多废弃的属性没有实际作用， * 内部类的设计 * @Data public class JavaObjectGenerateDTO {\n/** * 类名 */ private String className; /** * 对象名 */ private String objectName; /** * 列信息列表 */ private List\u0026lt;FieldDTO\u0026gt; fieldList; /** * 列信息 */ @Data public static class FieldDTO { /** * set 方法名 */ private String setMethod; /** * 值 */ private String value; } }\n1 2 * 枚举类的应用 * public enum MockTypeEnum {\nNONE(\u0026quot;不模拟\u0026quot;), INCREASE(\u0026quot;递增\u0026quot;), FIXED(\u0026quot;固定\u0026quot;), RANDOM(\u0026quot;随机\u0026quot;), RULE(\u0026quot;规则\u0026quot;), DICT(\u0026quot;词库\u0026quot;); private final String value; MockTypeEnum(String value) { this.value = value; } /** * 获取值列表 * * @return */ public static List\u0026lt;String\u0026gt; getValues() { return Arrays.stream(values()).map(MockTypeEnum::getValue).collect(Collectors.toList()); } /** * 根据 value 获取枚举 * * @param value * @return */ public static MockTypeEnum getEnumByValue(String value) { if (StringUtils.isBlank(value)) { return null; } for (MockTypeEnum mockTypeEnum : MockTypeEnum.values()) { if (mockTypeEnum.value.equals(value)) { return mockTypeEnum; } } return null; } public String getValue() { return value; } }\n1 2 * 门面模式使用，向客户端提供一个高层次接口，避免客户端大量调用子系统使整个系统的耦合性高。 * public static GenerateVO generateAll(TableSchema tableSchema) { // 校验 validSchema(tableSchema); SqlBuilder sqlBuilder = new SqlBuilder(); // 构造建表 SQL String createSql = sqlBuilder.buildCreateTableSql(tableSchema); int mockNum = tableSchema.getMockNum(); // 生成模拟数据 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; dataList = DataBuilder.generateData(tableSchema, mockNum); // 生成插入 SQL String insertSql = sqlBuilder.buildInsertSql(tableSchema, dataList); // 生成数据 json String dataJson = JsonBuilder.buildJson(dataList); // 生成 java 实体代码 String javaEntityCode = JavaCodeBuilder.buildJavaEntityCode(tableSchema); // 生成 java 对象代码 String javaObjectCode = JavaCodeBuilder.buildJavaObjectCode(tableSchema, dataList); // 生成 typescript 类型代码 String typescriptTypeCode = FrontendCodeBuilder.buildTypeScriptTypeCode(tableSchema); // 封装返回 GenerateVO generateVO = new GenerateVO(); generateVO.setTableSchema(tableSchema); generateVO.setCreateSql(createSql); generateVO.setDataList(dataList); generateVO.setInsertSql(insertSql); generateVO.setDataJson(dataJson); generateVO.setJavaEntityCode(javaEntityCode); generateVO.setJavaObjectCode(javaObjectCode); generateVO.setTypescriptTypeCode(typescriptTypeCode); return generateVO; } 1 2 3 4 5 6 * `CollectionUtils.isEmpty(dataList)` 判断列表是否为空或 * `DateUtils.parseDate(str, DATE_PATTERNS);` 第二个参数为一个字符串列表 * `public static \u0026lt;T\u0026gt; BaseResponse\u0026lt;T\u0026gt; success(T data) { return new BaseResponse\u0026lt;\u0026gt;(0, data, \u0026#34;ok\u0026#34;); }`对于泛型的使用 * ","date":"2023-05-19T21:24:35+08:00","permalink":"https://wangchenguang123.github.io/p/%E5%BC%80%E6%BA%90springboot%E9%A1%B9%E7%9B%AE-sql%E4%B9%8B%E7%88%B6/","title":"开源Springboot项目 Sql之父"},{"content":"笔记python并行 多线程、多进程、协程 1.多进程 每一个逻辑控制流都是一个进程，由内核来调度和维护。有独立的虚拟地址空间，数据是分开的，共享复杂，需要用IPC进行通信。占用内存较多，可靠性高 2.多线程 运行在一个单一进程上下文的逻辑流，由内核调度，多线程共享进程数据，共享简单，占用内存低，可靠性较低 3.协程 一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，先保存再恢复。 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 1 2 3 loop = asyncio.get_event_loop() 事件 tasks = [loop.create_task(func(*arg)) for arg in ____] 任务 loop.run_until_complete(asyncio.wait(tasks)) 执行 通过遍历tasks 后可获得返回值 task.result() asyncio.gather()方法也可以 * 自动将函数列表封装成了协程任务 done 为已完成的协程任务列表，pending 为超时未完成的协程任务类别，需通过task.result()方法可以获取每个协程任务返回的结果； 而asyncio.gather 返回的是所有已完成协程任务的 result，不需要再进行调用或其他操作，就可以得到全部结果。 在python3.7之后 利用asyncio.run可以代替上面3步 python中的多线程 1.GIL GIL（全局解释锁）不是python的特性和Lock不是一个层面的概念，在实现Cpython引入的一个概念。具备一定的优势： 1.在单线程任务中更快 2.在多线程任务中，对于I/O密集型程序运行更快。 一定的缺陷：1. 对于CPU密集型任务，需要进行用C语言包来实现。2、使python的多线程并不是真正意义的多线程 补充： 计算密集型：要进行大量的数值计算，例如进行上亿的数字计算、计算圆周率、对视频进行高清解码等等。这种计算密集型任务虽然也可以用多任务完成，但是花费的主要时间在任务切换的时间，此时CPU执行任务的效率比较低。 IO密集型：涉及到网络请求(time.sleep())、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。 2.GIL的运行过程 线程拿到GIL 执行逻辑代码，达到check_interval* 释放当前线程的GIL 所有线程竞争GIL 竞争到的线程又从第一步开始执行 补充：对于GIL的释放情景。 1.当前线程执行超时，自动释放。 2.当前线程执行阻塞操作时会自动释放。 3.执行完成时释放 3.GIL存在的问题 看似并行，实则不然，根据上述的运行过程可以看出，虽然是多线程但是线程之间的运行仍然是具有先后顺序的，并不是同时进行的。（一个进程中有一把全局解释锁，锁住线程） 可以利用多进程 + 协程来完成相应业务场景 python中的多进程 1. multiprocessing multiprocessing 模块在python中的多进程模块 1.多进程使用独立的内存空间相比于线程，代码更加直观 2.能够使用多个CPU/多核 3.避免GIL 4.子进程可以被kill（和thread不同） 5.multiprocessing有和threading.Thread类似的接口 基本模块的使用主要为Process类和Pool进程线程的创建和使用 close() 关闭pool，使其不在接受新的任务。 terminate() 结束工作进程，不在处理未完成的任务。 join() 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。 Pool可调用的方法： apply_async()异步 map_async生成子进程时使用的是list， imap和imap_unordered则是Iterable， 在速度上，map_async效率略高，而imap和 imap_unordered内存消耗显著的小。 在处理结果上，imap 和 imap_unordered 可以尽快返回一个Iterable的结果，而map_async则需要等待全部Task执行完毕，返回list。 而imap和imap_unordered 的区别是：imap 和 map_async一样，都按顺序等待Task的执行结果，而imap_unordered则不必。 imap_unordered返回的Iterable，会优先迭代到先执行完成的Task。 在对于多进程的实现当中还有两个模块，pp模块和pathos模块 在实现中主要关注异步并行； 异步执行指的是一批子进程并行执行，且子进程完成一个，就新开始一个，而不必等待同一批其他进程完成。 包括 pp.Server() submit方法、concurrent.futures.ProcessPoolExecutor() map方法。pathos.multiprocessing.ProcessPool() imap方法等 对于不同的参数也有相对应的方法 1.单任务，多参数 基本包的Process() future中的进程池submit()、multiprocessing.Pool()，apply_async方法、pp.Server()，submit方法 2.多任务，单参数 multiprocessing.Pool()，map_async，imap，imap_unordered方法 3.多任务，多参数 concurrent.futures.ProcessPoolExecutor() map方法、pathos.multiprocessing.ProcessPool()，map方法等 对于返回值也有一定分类 1.返回list 2.返回封装好的MapResult和ApplyResult,通过get（）方法获取值 3.返回迭代器，通过循环遍历获取值（按顺序不按顺序） 内存占用较小 2.多进程和多线程基本模块代码比较 在对于池化技术上，推荐使用进程池 进程池中包含两种方法，map（）和 submit（） map内部调用了submit，通过对submit封装使用起来更方便。map提交任务返回的是返回值的迭代器，submit提交任务返回的是Future类的实例。 需要提交任务并获得返回值时使用map。在需要提交任务并使用回调等功能的使用submit 使用map时，对于map传参的处理上。对于非迭代参数，需要使用partial偏函数进行处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from multiprocessing import Pool from functools import partial import numpy as np def adjust(mean, number): if number \u0026gt; mean: return 1 else: return 0 if __name__ == \u0026#34;__main__\u0026#34;: num_list = [12, 45, 67, 88, 99, 62] num_mean = np.mean(num_list) pool = Pool(4) pfunc = partial(adjust, num_mean) res_list = pool.map(pfunc, num_list) 3.多进程之间的通信 1.对于进程之间的通信，是没有线程之间简单的，在进程之间的通信中，有常用的两种Queue和pipe通信，对于进程池的使用上，运用队列通信的时候，我们要首先进行队列的创建 （1）队列 queue = multiprocessing.Manager().Queue() pool.apply_async(func1,args=(queue,)) pool.apply_async(func2, args=(queue,)) 完成进程之间的数据通信，通过队列中的基本方法，get（）和 put（） （2）pipe Pipe返回接收端和发送端，pipe[0]是接收，pipe[1]是发送 duplex=False表示半双工，发送端只能发送，接收端只能接受 duplex=True表示全双工，两端既能发送又能接收 parent_conn, child_conn = multiprocessing.Pipe() 创建管道 利用send（）和 recv（）方法进行传递和接收 ","date":"2022-07-06T21:22:51+08:00","permalink":"https://wangchenguang123.github.io/p/python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/","title":"Python并行计算"}]